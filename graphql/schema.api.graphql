# New plan:
# we will have getClub that does not page, returns clubDevice results but no game results
# listGames will page, returning everything for each game
# getGame will get everything for one game, should not need to page
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

enum DirectionLetter {
  N
  S
  E
  W
}

enum Strain {
  C
  D
  H
  S
  NT
}

enum Suit {
  C
  D
  H
  S
}

enum Rank {
  ACE
  TWO
  THREE
  FOUR
  FIVE
  SIX
  SEVEN
  EIGHT
  NINE
  TEN
  JACK
  QUEEN
  KING
}

enum Doubling {
  NONE
  DOUBLE
  REDOUBLE
}

enum BoardResultType {
  PLAYED
  PASSED_OUT
  NOT_BID_NOT_PLAYED
}

type Query {
  getClub(clubId: String!): Club
    @aws_cognito_user_pools(
      cognito_groups: ["adminClub", "adminSuper", "clubDevice"]
    )

  # These input arguments eliminate repetitive gql mutation strings that must list arguments twice
  listClubDevices(input: ListClubDevicesInput!): ListClubDevicesOutput!
    @aws_cognito_user_pools(cognito_groups: ["adminClub", "adminSuper"])

  listGames(input: ListGamesInput!): ListGamesOutput!
    @aws_cognito_user_pools(cognito_groups: ["adminClub", "adminSuper"])

  getGame(input: GetGameInput!): Game
    @aws_cognito_user_pools(
      cognito_groups: ["adminClub", "adminSuper", "clubDevice"]
    )
}
type Mutation {
  unexpectedError: UnexpectedErrorResponse!
    @aws_cognito_user_pools(cognito_groups: ["adminSuper"])

  createClub(input: CreateClubInput!): CreateClubResponse!
    @aws_api_key
    @aws_cognito_user_pools(cognito_groups: ["adminSuper"])
  updateClubName(input: UpdateClubNameInput!): UpdateClubNameResponse!
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "adminClub"])
  updateCurrentGameId(
    input: UpdateCurrentGameIdInput!
  ): UpdateCurrentGameIdResponse!
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "adminClub"])
  deleteClubAndAdmin(
    input: DeleteClubAndAdminInput!
  ): DeleteClubAndAdminResponse!
    @aws_cognito_user_pools(cognito_groups: ["adminClub", "adminSuper"])

  createClubDevice(input: CreateClubDeviceInput!): ClubDevice!
    @aws_cognito_user_pools(cognito_groups: ["adminClub", "adminSuper"])
  deleteClubDevice(input: DeleteClubDeviceInput!): ClubDevice!
    @aws_cognito_user_pools(cognito_groups: ["adminClub", "adminSuper"])

  createGame(input: CreateGameInput!): Game!
    @aws_cognito_user_pools(cognito_groups: ["adminClub", "adminSuper"])
  deleteGame(input: DeleteGameInput!): Game!
    @aws_cognito_user_pools(cognito_groups: ["adminClub", "adminSuper"])

  assignTable(input: AssignOrUnassignTableInput!): AssignTableResponse!
    @aws_cognito_user_pools(
      cognito_groups: ["adminSuper", "adminClub", "clubDevice"]
    )

  unassignTable(input: AssignOrUnassignTableInput!): UnassignTableResponse!
    @aws_cognito_user_pools(
      cognito_groups: ["adminSuper", "adminClub", "clubDevice"]
    )

  assignPlayer(input: AssignPlayerInput!): AssignPlayerResponse!
    @aws_cognito_user_pools(
      cognito_groups: ["adminSuper", "adminClub", "clubDevice"]
    )

  changeBoard(input: ChangeBoardInput!): ChangeBoardResponse
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "clubDevice"])

  assignContract(input: AssignContractInput!): BoardResult
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "clubDevice"])

  assignResult(input: AssignResultInput!): BoardResult
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "clubDevice"])
}

type Subscription {
  # These next three are for webapp-to-device communication to know when a device's current
  # game has been updated (automatically on create, and to null on delete)
  onCreateGame(clubId: String!): Game
    @aws_subscribe(mutations: ["createGame"])
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "clubDevice"])
  onDeleteGame(clubId: String!): Game
    @aws_subscribe(mutations: ["deleteGame"])
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "clubDevice"])
  onUpdateCurrentGameId(clubId: String!): UpdateCurrentGameIdResponse
    @aws_subscribe(mutations: ["updateCurrentGameId"])
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "clubDevice"])

  # This is for webapp-to-device communication to update the club's name
  onUpdateClubName(clubId: String!): UpdateClubNameResponse
    @aws_subscribe(mutations: ["updateClubName"])
    @aws_cognito_user_pools(cognito_groups: ["adminSuper", "clubDevice"])

  # These next two are for device-to-device communication to know which tables
  # are still available for assignment, and when all tables have been assigned
  onAssignTable(clubId: String!): AssignTableResponse
    @aws_subscribe(mutations: ["assignTable"])
    @aws_cognito_user_pools(
      cognito_groups: ["adminSuper", "adminClub", "clubDevice"]
    )
  onUnassignTable(clubId: String!): UnassignTableResponse
    @aws_subscribe(mutations: ["unassignTable"])
    @aws_cognito_user_pools(
      cognito_groups: ["adminSuper", "adminClub", "clubDevice"]
    )

  # This is for for device-to-device communication to know player names for display
  # after round 1
  onAssignPlayer(clubId: String!): AssignPlayerResponse
    @aws_subscribe(mutations: ["assignPlayer"])
    @aws_cognito_user_pools(
      cognito_groups: ["adminSuper", "adminClub", "clubDevice"]
    )
}

input ListClubDevicesInput {
  clubId: String!
  nextToken: String
  limit: Int
}

type ListClubDevicesOutput {
  items: [ClubDevice]!
  nextToken: String
}

input ListGamesInput {
  clubId: String!
  nextToken: String
  limit: Int = 50
  finalGameFromLastList: PartialGame
}

type ListGamesOutput {
  items: [Game]!
  nextToken: String
}

type Club {
  id: String!
  name: String!
  currentGameId: String
  createdAt: AWSDateTime!
}

type ClubDevice {
  clubId: String!
  clubDeviceId: String!
  name: String!
  email: AWSEmail!
  createdAt: AWSDateTime!
}

input CreateClubDeviceInput {
  clubId: String!
  deviceName: String!
  regToken: String!
}

input DeleteClubDeviceInput {
  clubId: String!
  clubDeviceId: String!
}

type PlayerAssignment {
  directionLetter: DirectionLetter!
  playerId: String!
  playerDisplayName: String!
}

type BoardResult {
  type: BoardResultType
  board: Int
  round: Int
  level: Int
  strain: Strain
  doubling: Doubling
  declarer: DirectionLetter
  leadRank: Rank
  leadSuit: Suit
  result: Int
}

input PartialBoardResult {
  type: BoardResultType
  board: Int
  round: Int
  level: Int
  strain: Strain
  doubling: Doubling
  declarer: DirectionLetter
  leadRank: Rank
  leadSuit: Suit
  result: Int
}
type TableAssignment {
  tableNumber: Int!
  clubDeviceId: String!
  playerAssignments: [PlayerAssignment!]!
  round: Int
  board: Int
  results: [BoardResult!]!
}

input PartialTableAssignment {
  tableNumber: Int!
  clubDeviceId: String!
  playerAssignments: [PartialPlayerAssignment!]!
  round: Int
  board: Int
  results: [PartialBoardResult!]!
}

input PartialPlayerAssignment {
  directionLetter: DirectionLetter!
  playerId: String!
  playerDisplayName: String!
}

input AssignOrUnassignTableInput {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
}

type AssignTableResponse {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  round: Int
  board: Int
  playerAssignments: [PlayerAssignment!]!
  results: [BoardResult!]!
}

type UnassignTableResponse {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  round: Int
  board: Int
}

input AssignPlayerInput {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  directionLetter: DirectionLetter!
  playerId: String!
  playerDisplayName: String!
}

type AssignPlayerResponse {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  directionLetter: DirectionLetter!
  playerId: String!
  playerDisplayName: String!
}

input GetGameInput {
  clubId: String!
  gameId: String!
}

type Game {
  clubId: String!
  gameId: String!
  movement: String!
  tableCount: Int!
  roundCount: Int!
  boardsPerRound: Int!
  label: String
  tableAssignments: [TableAssignment!]!
  createdAt: AWSDateTime!
}

input PartialGame {
  clubId: String!
  gameId: String!
  movement: String!
  tableCount: Int!
  roundCount: Int!
  boardsPerRound: Int!
  label: String
  tableAssignments: [PartialTableAssignment!]!
  createdAt: AWSDateTime!
}

input CreateGameInput {
  clubId: String!
  movement: String!
  tableCount: Int!
  roundCount: Int!
  boardsPerRound: Int!
  label: String
}

input DeleteGameInput {
  clubId: String!
  gameId: String!
}

type UnexpectedErrorResponse {
  neverGetsReturned: String!
    @aws_cognito_user_pools(cognito_groups: ["adminSuper"])
}

input CreateClubInput {
  newAdminEmail: AWSEmail!
  newClubName: String!
  suppressInvitationEmail: Boolean
  recaptchaToken: String!
}

type CreateClubResponse {
  userId: String!
    @aws_api_key
    @aws_cognito_user_pools(cognito_groups: ["adminSuper"])
  clubId: String!
    @aws_api_key
    @aws_cognito_user_pools(cognito_groups: ["adminSuper"])
}

input UpdateClubNameInput {
  clubId: String!
  newName: String!
}

type UpdateClubNameResponse {
  clubId: String!
  newClubName: String!
}

input UpdateCurrentGameIdInput {
  clubId: String!
  newGameId: String!
}

type UpdateCurrentGameIdResponse {
  clubId: String!
  newCurrentGameId: String!
}

type ClearCurrentGameIdResponse {
  clubId: String!
}

input DeleteClubAndAdminInput {
  userId: String!
  clubId: String!
}

type DeleteClubAndAdminResponse {
  status: String!
}

input ChangeBoardInput {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  board: Int
  round: Int
}

type ChangeBoardResponse {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  board: Int
  round: Int
}

input AssignContractInput {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  board: Int!
  round: Int!
  level: Int!
  strain: Strain!
  declarer: DirectionLetter!
  doubling: Doubling!
  leadSuit: Suit!
  leadRank: Rank!
}

input AssignResultInput {
  clubId: String!
  clubDeviceId: String!
  gameId: String!
  tableNumber: Int!
  board: Int!
  round: Int!
  type: BoardResultType!
  result: Int
}
